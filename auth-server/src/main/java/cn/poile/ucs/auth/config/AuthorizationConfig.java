package cn.poile.ucs.auth.config;import cn.poile.ucs.auth.granter.MobileCodeTokenGranter;import cn.poile.ucs.auth.service.UserDetailsServiceImpl;import cn.poile.ucs.auth.util.UserDetailImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.*;import org.springframework.security.oauth2.provider.client.BaseClientDetails;import org.springframework.security.oauth2.provider.password.ResourceOwnerPasswordTokenGranter;import org.springframework.security.oauth2.provider.refresh.RefreshTokenGranter;import org.springframework.security.oauth2.provider.token.DefaultTokenServices;import org.springframework.security.oauth2.provider.token.TokenEnhancer;import org.springframework.security.oauth2.provider.token.TokenEnhancerChain;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;import org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;import java.util.*;import java.util.concurrent.TimeUnit;/** * 认证配置 * @author: yaohw * @create: 2019-09-30 16:12 **/@Configuration@EnableAuthorizationServerpublic class AuthorizationConfig extends AuthorizationServerConfigurerAdapter {    @Autowired    private AuthenticationManager authenticationManager;    @Autowired    private UserDetailsServiceImpl userDetailsService;    @Autowired    private RedisConnectionFactory redisConnectionFactory;    @Bean    public ClientDetailsService clientDetails() {        return new ClientDetailsService() {            @Override            public ClientDetails loadClientByClientId(String clientId) throws ClientRegistrationException {                BaseClientDetails clientDetails = new BaseClientDetails();                clientDetails.setAuthorities(new ArrayList<>());                clientDetails.setClientId("yaohw");                clientDetails.setClientSecret("$2a$10$CwIutywnbs9bifHaY3Ezu.gYkWi4Zano8gVPq08hXjal6.uj.Yzuy");                //设置accessToken和refreshToken的时效，如果不设置则使tokenServices的配置的                clientDetails.setAccessTokenValiditySeconds((int)TimeUnit.HOURS.toSeconds(2));                clientDetails.setRefreshTokenValiditySeconds((int)TimeUnit.DAYS.toSeconds(30));                //clientDetails.setClientSecret("yaohw");                List<String> scopes = new ArrayList<>(1);                scopes.add("sever");                clientDetails.setScope(scopes);                List<String> grantTypes = new ArrayList<>(2);                grantTypes.add("password");                grantTypes.add("refresh_token");                grantTypes.add("mobile");                clientDetails.setAuthorizedGrantTypes(grantTypes);                return clientDetails;            }        };    }    /**     * 配置token存储，这个配置token存到redis中     * @return     */    @Bean    public TokenStore tokenStore() {        return new RedisTokenStore(redisConnectionFactory);    }    /**     * 配置客户端详情     * @param clients     * @throws Exception     */    @Override    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {        clients.withClientDetails(clientDetails());    }    @Override    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {        //采用token转jwt，并添加一些自定义信息（有默认非必须）        TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();        tokenEnhancerChain.setTokenEnhancers(                Arrays.asList(jwtAccessTokenConverter(),tokenEnhancer()));        endpoints.tokenEnhancer(tokenEnhancerChain)                //配置token存储，一般配置redis存储                .tokenStore(tokenStore())                //配置认证管理器                .authenticationManager(authenticationManager)                //配置用户详情server，密码模式必须                .userDetailsService(userDetailsService)                //配置grant_type模式，如果不配置则默认使用密码模式、简化模式、验证码模式以及刷新token模式，如果配置了只使用配置中，默认配置失效                //具体可以查询AuthorizationServerEndpointsConfigurer中的getDefaultTokenGranters方法                .tokenGranter(tokenGranter(endpoints));        // 配置TokenServices参数        DefaultTokenServices tokenServices = new DefaultTokenServices();        tokenServices.setTokenStore(endpoints.getTokenStore());        // 是否支持刷新Token        tokenServices.setSupportRefreshToken(true);        tokenServices.setReuseRefreshToken(true);        tokenServices.setClientDetailsService(endpoints.getClientDetailsService());        tokenServices.setTokenEnhancer(endpoints.getTokenEnhancer());        //设置accessToken和refreshToken的默认超时时间(如果clientDetails的为null就取默认的，如果clientDetails的不为null取clientDetails中的)        tokenServices.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(2));        tokenServices.setRefreshTokenValiditySeconds((int) TimeUnit.DAYS.toSeconds(30));        endpoints.tokenServices(tokenServices);    }    /**     * jwt格式封装token     * @return     */    @Bean    public JwtAccessTokenConverter jwtAccessTokenConverter() {        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();        //设置jwt加解密秘钥，不设置会随机一个        jwtAccessTokenConverter.setSigningKey("yaohw");        return jwtAccessTokenConverter;    }    /**     * jwt 生成token 定制化处理，添加一些元信息     *     * @return TokenEnhancer     */    @Bean    public TokenEnhancer tokenEnhancer() {        return (accessToken, authentication) -> {            final Map<String, Object> additionalInfo = new HashMap<>(2);            additionalInfo.put("license", "yaohw");            UserDetailImpl user = (UserDetailImpl) authentication.getUserAuthentication().getPrincipal();            if (user != null) {                additionalInfo.put("username", user.getUsername());            }            ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);            return accessToken;        };    }    @Override    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {        security                .allowFormAuthenticationForClients()                .tokenKeyAccess("permitAll()")                .checkTokenAccess("isAuthenticated()");    }    /**     * 创建grant_type列表     * @param endpoints     * @return     */    private TokenGranter tokenGranter(AuthorizationServerEndpointsConfigurer endpoints) {        List<TokenGranter> list = new ArrayList<>();        list.add(new ResourceOwnerPasswordTokenGranter(authenticationManager, endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory()));        list.add(new RefreshTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory()));        list.add(new MobileCodeTokenGranter(authenticationManager,endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory()));        return new CompositeTokenGranter(list);    }}